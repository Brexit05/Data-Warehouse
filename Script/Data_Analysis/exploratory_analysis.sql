/*This SQL script is a comprehensive exploration and analysis of a star schema-based data warehouse, leveraging views from the gold layer: dim_customers, dim_products, and fact_sales. It provides insights into data structure, customer behavior, product performance, sales trends, and more.*/

USE [DataWarehouse];

-- Database Exploration
SELECT*
FROM INFORMATION_SCHEMA.TABLES;

-- Columns Exploration
SELECT *
FROM INFORMATION_SCHEMA.COLUMNS;

-- Dimensions Exploration
-- Explore all countries our customers come from
SELECT DISTINCT country
FROM gold.dim_customers;

-- Explore all Categories
SELECT DISTINCT category,sub_category,product_name
FROM gold.dim_products
ORDER BY 1,2,3;

-- Date Exploration
SELECT MIN(birth_date) AS youngest_birthdate,
	   MAX(birth_date) AS oldest_birthdate,
	   DATEDIFF(year,MIN(birth_date),GETDATE()) AS oldest_age,
	   DATEDIFF(year,MAX(birth_date), GETDATE()) AS youngest_age,
	   DATEDIFF(year,MIN(birth_date),MAX(birth_date)) AS age_range
FROM gold.dim_customers;

-- Measures Exploration
-- Find the total sales
SELECT SUM(sales) AS total_sales
FROM gold.fact_sales;

-- Find how many items are sold
SELECT SUM(quantity) AS total_quantity
FROM gold.fact_sales;

-- Find the average selling price
SELECT AVG(price) AS avg_price
FROM gold.fact_sales;

--Find the total number of orders
SELECT COUNT(DISTINCT(order_number)) AS total_orders
FROM gold.fact_sales;

-- Find the total number of products
SELECT COUNT(product_key) AS total_products
FROM gold.fact_sales;

-- Find the total number of customers
SELECT COUNT(customer_id) AS total_customers
FROM gold.fact_sales;

-- Find the total number of customers that has placed an order
SELECT COUNT(DISTINCT(customer_id)) AS total_customers
FROM gold.fact_sales;

-- Generating a report
SELECT 'Total Sales' AS measure_name, SUM(sales) AS measure_value
FROM gold.fact_sales
UNION ALL
SELECT 'Total Quantity' AS measure_name, SUM(quantity) AS measure_value
FROM gold.fact_sales
UNION ALL
SELECT 'Average Price' AS measure_name, AVG(price) AS measure_value
FROM gold.fact_sales
UNION ALL
SELECT 'Total Orders' AS measure_name, COUNT(DISTINCT(order_number)) AS measure_value
FROM gold.fact_sales
UNION ALL
SELECT 'Total Products' AS measure_name,COUNT(product_key) AS measure_value
FROM gold.fact_sales
UNION ALL
SELECT 'Total Customers' AS measure_name,COUNT(customer_id) AS measure_value
FROM gold.fact_sales;

-- Magnitude Analysis
-- Total customers by country
SELECT country, COUNT(customer_key) AS total_customers
FROM gold.dim_customers
GROUP BY country
ORDER BY total_customers DESC;

-- Total customers by gender
SELECT gender, COUNT(customer_id) AS total_customers
FROM gold.dim_customers
GROUP BY gender
ORDER BY total_customers DESC;

-- Total products by category
SELECT category, COUNT(*) AS total_products
FROM gold.dim_products
GROUP BY category
ORDER BY total_products DESC;

-- Average costs in each category
SELECT category, ROUND(AVG(cost),2) AS avg_cost
FROM gold.dim_products
GROUP BY category
ORDER BY avg_cost DESC;

-- Total revenue generated for each category
SELECT d.category, SUM(f.sales) AS total_revenue
FROM gold.dim_products AS d
RIGHT JOIN gold.fact_sales AS f
ON d.product_key = f.product_key
GROUP BY d.category
ORDER BY total_revenue DESC;

-- Total revenue generated by each customer
SELECT 
c.customer_key,
c.first_name,
c.last_name,
SUM(f.sales) AS total_revenue
FROM gold.fact_sales AS f
LEFT JOIN gold.dim_customers AS c
ON c.customer_id = f.customer_id
GROUP BY c.customer_key, c.first_name,c.last_name
ORDER BY total_revenue DESC;

-- Distribution of sold items across countries
SELECT 
c.country,
SUM(f.quantity) AS total_sold_items
FROM gold.fact_sales AS f
LEFT JOIN gold.dim_customers AS c
ON c.customer_id = f.customer_id
GROUP BY c.country
ORDER BY total_sold_items DESC;

-- Ranking Analysis
-- We are going to order the values of our dimension by measure
-- Which 5 products generated the highest revenue?
SELECT TOP 5 p.product_name, SUM(f.sales) AS total_revenue
FROM gold.dim_products AS p
RIGHT JOIN gold.fact_sales AS f
ON p.product_key = f.product_key
GROUP BY p.product_name
ORDER BY total_revenue DESC;

-- Which 5 products generated the lowest revenue?
SELECT TOP 5 p.product_name, SUM(f.sales) AS total_revenue
FROM gold.dim_products AS p
RIGHT JOIN gold.fact_sales AS f
ON p.product_key = f.product_key
GROUP BY p.product_name
ORDER BY total_revenue ASC;

-- Computing sales over time
SELECT 
MONTH(order_date) AS order_month,
YEAR(order_date) AS order_year,
SUM(sales) AS total_sales,
COUNT(DISTINCT customer_id) AS total_customers,
SUM(quantity) AS total_quantity
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY YEAR(order_date), MONTH(order_date)
ORDER BY YEAR(order_date), MONTH(order_date);

--Calculating the running total sales and moving average
SELECT 
order_month,
order_year,
total_sales,
SUM(total_sales) OVER(ORDER BY order_month,order_year) AS running_total_sales,
SUM(avg_price) OVER(ORDER BY order_month,order_year) AS moving_average_price
FROM(
SELECT 
MONTH(order_date) AS order_month,
YEAR(order_date) AS order_year,
SUM(sales) AS total_sales,
COUNT(DISTINCT customer_id) AS total_customers,
SUM(quantity) AS total_quantity,
AVG(price) AS avg_price
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY YEAR(order_date), MONTH(order_date)) AS t;

-- Performance Analysis
/* Analyze the yearly performance of products by comparing their sales to both 
the average sales performance of the product and the previous years's sales*/
WITH yearly_product_sales AS ( 
SELECT
YEAR(order_date) AS order_year,
p.product_name,
SUM(f.sales) AS current_sales
FROM gold.fact_sales AS f
LEFT JOIN gold.dim_products AS p
ON f.product_key = p.product_key
WHERE f.order_date IS NOT NULL
GROUP BY YEAR(f.order_date),p.product_name
)
SELECT 
order_year,
product_name,
current_sales,
AVG(current_sales) OVER(PARTITION BY product_name) AS avg_sales,
current_sales - AVG(current_sales) OVER(PARTITION BY product_name) AS diff_avg,
CASE 
	WHEN current_sales - AVG(current_sales) OVER(PARTITION BY product_name) < 0 THEN 'Below Avg'
	WHEN current_sales - AVG(current_sales) OVER(PARTITION BY product_name) > 0 THEN 'Above Avg'
	ELSE 'Avg'
	END AS avg_change,
-- Year over Year Analysis
LAG(current_sales) OVER(PARTITION BY product_name ORDER BY order_year) AS py_sales,
current_sales - LAG(current_sales) OVER(PARTITION BY product_name ORDER BY order_year) AS diff_py,
CASE
	WHEN current_sales - LAG(current_sales) OVER(PARTITION BY product_name ORDER BY order_year) <0 THEN 'Decrease'
	WHEN current_sales - LAG(current_sales) OVER(PARTITION BY product_name ORDER BY order_year) > 0 THEN 'Increase'
	ELSE 'No change'
	END AS py_change
FROM yearly_product_sales
ORDER BY product_name, order_year;


-- Part to Whole Analysis
-- Which categories contribute the most to overall sales?
WITH category_sales AS (
SELECT
category,
SUM(sales) AS  total_sales
FROM gold.fact_sales AS f
LEFT JOIN gold.dim_products AS p
ON p.product_key = f.product_key
GROUP BY category)
SELECT 
category,
total_sales,
SUM(total_sales) OVER() AS overall_sales,
CONCAT(ROUND((CAST(total_sales AS FLOAT)/SUM(total_sales) OVER()) * 100,2),'%') AS percentage_total
FROM category_sales; 


-- Data segmentation
--Segment products into cost ranges and count how many products fall into each segment
WITH product_segment AS (
SELECT 
product_key,
product_name,
cost,
CASE
	WHEN cost < 100 THEN 'Below 100'
	WHEN cost BETWEEN 100 AND 500 THEN '100-500'
	WHEN cost BETWEEN 500 AND 900 THEN '500-900'
	WHEN cost BETWEEN 900 AND 1300 THEN '900-1300'
	WHEN cost BETWEEN 1300 AND 1700 THEN '1300-1700'
	WHEN cost BETWEEN 1700 AND 2100 THEN '1700-2100'
	ELSE 'Above 2100'
END AS cost_range
FROM gold.dim_products)
SELECT cost_range, COUNT(*) AS product_count
FROM product_segment
GROUP BY cost_range
ORDER BY product_count ASC;

--Group customers into three segments based on their spending behavior
WITH segment AS 
(
SELECT
customer_id,
total_spending,
life_span,
CASE
	WHEN life_span >=12 AND total_spending > 5000 THEN 'VIP'
	WHEN life_span >=12 AND total_spending <= 5000 THEN 'Regular'
	ELSE 'New'
END AS customer_segment
FROM
(
SELECT 
c.customer_id,
SUM(f.sales) AS total_spending,
MIN(f.order_date) first_order,
MAX(f.order_date) AS last_order,
DATEDIFF(month,MIN(f.order_date),MAX(f.order_date)) AS life_span
FROM gold.fact_sales AS f
LEFT JOIN gold.dim_customers AS c
ON f.customer_id = c.customer_id
GROUP BY c.customer_id
) AS t)
SELECT
customer_segment,
COUNT(*) AS total_customers
FROM segment
GROUP BY customer_segment
ORDER BY total_customers DESC;
